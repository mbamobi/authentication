import { Injectable } from '@angular/core';
import { Request as RequestAngular, Headers, URLSearchParams } from '@angular/http';
import { Resolve } from './resolve';
export var Request = (function () {
    function Request(resolve) {
        this.resolve = resolve;
        this.defaultOptions = {};
    }
    Request.prototype.getResolve = function () {
        return this.resolve;
    };
    Request.prototype.getMetadata = function () {
        return this.getResolve().getMetadata();
    };
    Request.prototype.create = function (id, params, options) {
        if (options === void 0) { options = {}; }
        var defaultOptions = Object.assign({}, this.defaultOptions);
        options = Object.assign(defaultOptions, options);
        options.headers = options.headers || {};
        var headersDefault = this.getMetadata().getHeaders(id);
        for (var index in options.headers) {
            headersDefault[index] = options.headers[index];
        }
        var copyParams = Object.assign({}, params);
        Object.assign(options, {
            method: options.method || this.getMetadata().getMethod(id),
            url: this.resolve.url(id, copyParams),
            headers: new Headers(headersDefault)
        });
        if (copyParams && Object.keys(copyParams).length) {
            this.serializeParams(id, options, copyParams);
        }
        return new RequestAngular(options);
    };
    Request.prototype.setDefaultOptions = function (options) {
        this.defaultOptions = options;
    };
    Request.prototype.serializeParams = function (id, options, params) {
        switch (options.method) {
            case 'GET':
            case 'DELETE':
                this.resolve.validateParams(id, Object.assign({}, params), true);
                options.search = this.createSearchParams(params);
                break;
            case 'POST':
            case 'PUT':
                if (!options.body) {
                    options.body = params;
                    var contentType = options.headers.get('content-type');
                    if (!contentType) {
                        options.body = this.createSearchParams(params);
                    }
                }
                break;
        }
    };
    Request.prototype.createSearchParams = function (params) {
        var search = new URLSearchParams('');
        for (var param in params) {
            if (typeof params[param] === 'object') {
                search.set(param, JSON.stringify(params[param]));
            }
            else {
                search.set(param, params[param]);
            }
        }
        return search;
    };
    Request.decorators = [
        { type: Injectable },
    ];
    Request.ctorParameters = [
        { type: Resolve, },
    ];
    return Request;
}());
//# sourceMappingURL=request.js.map